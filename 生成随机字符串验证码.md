在Java中生成类似"A7WJFY"的随机且不重复的字符串（由大写字母和数字组成），可以通过以下两种方式实现。根据业务场景选择最适合的方案：

---

### **方法一：随机生成 + 唯一性校验**
适用于数据量不大或冲突概率较低的场景，直接生成随机字符串后通过数据库唯一索引去重。

#### **代码实现**
```java
import java.security.SecureRandom;
import java.util.Collections;

public class RandomCodeUtils {

    private static final String CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    private static final SecureRandom RANDOM = new SecureRandom();

    /**
     * 生成随机字符串
     * @param length 字符串长度
     * @return 随机字符串，如"A7WJFY"
     */
    public static String generate(int length) {
        StringBuilder sb = new StringBuilder(length);
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(CHARACTERS.length());
            sb.append(CHARACTERS.charAt(index));
        }
        return sb.toString();
    }
}
```

#### **使用示例**
```java
public class UserService {
    
    // 假设已注入UserDao
    private UserDao userDao;

    /**
     * 插入用户（自动生成唯一昵称）
     * @param maxAttempts 最大尝试次数
     */
    public void insertUserWithUniqueNickname(int maxAttempts) {
        for (int i = 0; i < maxAttempts; i++) {
            String nickname = RandomCodeUtils.generate(6); // 生成6位随机码
            try {
                userDao.insert(nickname, ...其他字段); // 插入数据库
                return;
            } catch (DuplicateKeyException e) {
                // 如果昵称重复，继续生成
                continue;
            }
        }
        throw new RuntimeException("无法生成唯一昵称");
    }
}
```

---

### **方法二：基于递增序列的编码**
适用于需要绝对唯一性且可预测的场景（如订单号），通过将递增的数值转换为Base36编码。

#### **代码实现**
```java
public class Base36Encoder {

    private static final String CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    private static final int BASE = CHARACTERS.length();

    /**
     * 将长整型数值编码为Base36字符串
     * @param num 输入数值（需自增）
     * @param length 输出字符串长度（不足时左侧补零）
     */
    public static String encode(long num, int length) {
        StringBuilder sb = new StringBuilder();
        while (num > 0) {
            sb.append(CHARACTERS.charAt((int) (num % BASE)));
            num /= BASE;
        }
        String code = sb.reverse().toString();
        return String.format("%" + length + "s", code).replace(' ', '0'); // 左侧补零
    }
}
```

#### **使用示例**
```java
public class UserService {
    
    private AtomicLong counter = new AtomicLong(0); // 自增序列

    public void insertUser() {
        long id = counter.incrementAndGet(); // 获取自增ID
        String nickname = Base36Encoder.encode(id, 6); // 转换为6位Base36
        userDao.insert(nickname, ...其他字段); // 插入数据库
    }
}
```

---

### **两种方案对比**
| **特性**       | **随机生成 + 唯一性校验**      | **基于递增序列的编码**                 |
| -------------- | ------------------------------ | -------------------------------------- |
| **唯一性保证** | 依赖数据库唯一索引或内存去重   | 绝对唯一（依赖自增序列）               |
| **可读性**     | 随机字符串，无规律             | 递增规律（如000001 → 000002）          |
| **适用场景**   | 需要随机性的场景（如用户昵称） | 需要严格递增且可预测的场景（如订单号） |
| **冲突风险**   | 数据量大时需控制重试次数       | 无冲突                                 |
| **分布式支持** | 需分布式锁或数据库协调         | 需分布式ID生成算法（如Snowflake）      |

---

### **其他优化建议**
1. **增加字符长度**  
   将字符串长度从6位增加到8位或更长，可显著降低随机冲突概率（如8位有36^8≈2.8万亿种组合）。
   
2. **混合时间戳**  
   在随机码中嵌入时间戳（如年月日），进一步提高唯一性：
   ```java
   public static String generateWithTimestamp() {
       SimpleDateFormat sdf = new SimpleDateFormat("yyMMdd");
       String timePart = sdf.format(new Date());
       String randomPart = generate(3); // 生成3位随机码
       return timePart + randomPart; // 如"230804A7W"
   }
   ```

3. **分布式唯一性**  
   若为分布式系统，使用Snowflake算法生成唯一ID后，再将其转换为Base36：
   ```java
   long snowflakeId = generateSnowflakeId(); // 生成分布式ID
   String code = Base36Encoder.encode(snowflakeId, 10); // 转为Base36
   ```