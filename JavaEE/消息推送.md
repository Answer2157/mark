# (一)消息推送常见方式

### **轮询方式**

#### 轮询

**轮询**指浏览器以指定的时间间隔向服务器发出HTTP请求，服务器实时返回数据给浏览器。

![image-20250130093440962](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250130093440962.png)

#### 长轮询

**长轮询**指的是浏览器发出ajax请求，服务器端接收到请求后，会阻塞请求直到有效数据或者超时才返回。          

![image-20250130093512033](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250130093512033.png)

#### SSE(server-sent event):服务器发送事件

- SSE在服务器和客户端之间打开一个单向通道
- 服务器端响应的不再是一次性的数据包，而是text/event-stream类型的数据流信息
- 服务器有数据变更时将数据流传输到客户端

![image-20250130095445816](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250130095445816.png)

#### websocket

# (二)WebSocket

## WebSocket介绍

**WebSocket**是一种基于TCP连接上进行全双工通信的协议

![image-20250130100029233](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250130100029233.png)

**说明：**

**全双工(Full Duplex):**允许数据在两个方向上同时传输。
**半双工(Half Duplex)**:允许数据在两个方向上传输，但是同一个时间段内只允许一个方向上传输。

### 原理解析

![image-20250130101215966](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250130101215966.png)

## 客户端API

### websocket对象创建

~~~js
let ws = new WebSocket(URL)

URL说明：
格式：协议://ip地址/访问路径
协议：协议名称为ws
~~~

### websocket对象相关事件

| 事件    | 事件处理程序 | 描述                               |
| ------- | ------------ | ---------------------------------- |
| open    | ws.onopen    | 连接建立时触发                     |
| message | ws.onmessage | 客户端接收到服务器发送的数据时触发 |
| close   | ws.onclose   | 连接关闭时触发                     |

### websocket对象提供的方法

| 方法名称 | 描述                                        |
| -------- | ------------------------------------------- |
| send()   | 通过websocket对象调用该方法发送数据给服务端 |

 ~~~js
 //代码样例 
 <script>
 	let ws = new WebSocket("ws://localhost/chat");
 	ws.onopen function(){
         
 	}
 	ws.onmessage function(evt){
 	//通过evt.data可以获取服务器发送的数橱
 	};
 	ws.onclose function(){ 
         
 	};
 </script>
 ~~~

## 服务端API

Tomcat的7.0.5版本开始支持WebSocket并且实现了Java WebSocket规范.
Java WebSocket应用由一系列的Endpoint组成。Endpoint是一个java对象，代表WebSocket链接的一端，对于服务端，我们可以视为处理具体WebSocket消息的接口。
我们可以通过两种方式定义Endpoint:

- 第一种是编程式，即继承类javax.websocket.Endpoint并实现其方法。
- 第二种是注解式，即定义一个POJO,并添加@ServerEndpoint相关注解。

Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接过程中有效，最后在链接关闭时结束。在Endpoint接口中明确定义了与其生命周期相关的方法，规范实现者确保生命周期的各个阶段调用实例的相关方法。生命周期方法如下：

| 方法      | 描述                                                         | 注解     |
| --------- | ------------------------------------------------------------ | -------- |
| onOpen()  | 当开启一个新的会话时调用，该方法是客户端与服务端握手成功后调用的方法 | @OnOpen  |
| onClose() | 当会话关闭时调用                                             | @OnClose |
| onError() | 当连接过程异常时调用                                         | @OnError |

### 服务端如何接收客户端发送的数据呢？

- 编程式：通过添加MessageHander消息处理器来接收信息
- 注解式：在定义Endpoint时，通过@OnMessage注解指定接收消息的方法

### 服务端如何推送数据给客户端呢？

发送消息则由RemoteEndpoint完成，其实例由Session维护。
发送消息有2种方式发送消息

- 通过session.getBasicRemote获取同步消息发送的实例，然后调用其sendXxx)方法发送消息
- 通过session.getAsyncRemote获取异步消息发送实例，然后调用其sendXxx)方法发送消息

### **样例**

~~~java
@ServerEndpoint("/chat")
@Component
public class ChatEndpoint{
	@OnOpen
	//连接建立时被调用
	public void onopen(Session session,EndpointConfig config){
        
    
    }
    
	@OnMessage
	//接收到客户端发送的数据时被调用
	public void onMessage(String message){
        
    }
    
	@Onclose
	//连接关闭时被调用
	public void onclose(Session session){
        
    }
}
~~~

# (三)在线聊天室demo

### 流程分析

 ![image-20250221105632834](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250221105632834.png)

### 消息格式设计

- **客户端——>服务端**

  {"toName":"张三","message":"你好"}

- **服务端——>客户端**

  1. 系统消息推送格式:{"system":true,"fromName":null,"message":["李四", "王五"]}
  2. 推送给某一个用户的消息格式:{"system":false,"fromName":"张三","message":"你好"}

### 代码实现

#### 1. 引入坐标

~~~xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
~~~

#### 2.编写配置类，扫描添加有@ServerEndpoint注解的Bean

~~~java
@Configuration
public class webSocketConfig {

    @Bean
    /**
     * 注入ServerEndpointExporter，
     * 这个bean会自动注册使用@ServerEndpoint注解申明的websocket endpoint
     */
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}
~~~

#### 3.编写配置类，用于获取HttpSession对象

~~~java
public class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {
    @Override
    public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
        HttpSession httpSession = (HttpSession) request.getHttpSession();
        // 将HttpSession对象存储到WebSocket的Session中
        sec.getUserProperties().put(HttpSession.class.getName(), httpSession);
    }
}
~~~

#### 4.在@ServerEndpoint注解中引入配置器

~~~Java
@ServerEndpoint(value ="/chat",configurator = GetHttpSessionConfigurator.class)
~~~



# websocket的吐血理解



在Java中使用WebSocket时，`@ServerEndpoint`及`@OnOpen`、`@OnClose`、`OnMessage`等注解的用途和实际使用方法如下：

---

### 1. @ServerEndpoint("/webSocket") 的作用
- **意义**：这个注解将一个Java类标记为WebSocket服务器的**端点（Endpoint）**，并指定客户端连接的URI（例如`ws://localhost:8080/webSocket`）。
- **为什么需要**：它告诉服务器“当客户端通过指定URI发起WebSocket连接时，由这个类处理请求”。没有这个注解，服务器无法识别该类的WebSocket功能。

---

### **2. 生命周期注解的作用**
- **`@OnOpen`**：当客户端与服务器建立WebSocket连接时触发。通常用于初始化操作（如保存会话、记录日志）。
  ```java
  @OnOpen
  public void onOpen(Session session) {
      System.out.println("客户端连接: " + session.getId());
  }
  ```

- **`@OnMessage`**：当服务器收到客户端发送的消息时触发。核心业务逻辑（如处理消息、广播回复）写在这里。
  ```java
  @OnMessage
  public void onMessage(String message, Session session) {
      System.out.println("收到消息: " + message);
      session.getBasicRemote().sendText("服务器回复: " + message);
  }
  ```

- **`@OnClose`**：当连接关闭时触发。用于清理资源（如移除会话、记录日志）。
  ```java
  @OnClose
  public void onClose(Session session) {
      System.out.println("连接关闭: " + session.getId());
  }
  ```

---

### **3. 如何使用WebSocket？**
#### **服务端代码示例**
```java
@ServerEndpoint("/webSocket") // 声明这是一个WebSocket端点
public class MyWebSocket {

    @OnOpen
    public void onOpen(Session session) {
        System.out.println("新连接: " + session.getId());
    }

    @OnMessage
    public void onMessage(String message, Session session) {
        System.out.println("收到消息: " + message);
        // 向客户端发送回复
        session.getBasicRemote().sendText("服务器已收到: " + message);
    }

    @OnClose
    public void onClose(Session session) {
        System.out.println("连接关闭: " + session.getId());
    }
}
```

#### **前端JavaScript连接示例**
```javascript
// 建立WebSocket连接
const socket = new WebSocket('ws://localhost:8080/webSocket');

// 连接建立时触发
socket.onopen = () => {
    console.log('已连接到服务器');
    socket.send('Hello Server!');
};

// 收到服务器消息时触发
socket.onmessage = (event) => {
    console.log('收到服务器消息:', event.data);
};

// 连接关闭时触发
socket.onclose = () => {
    console.log('连接已关闭');
};
```

---

### **4. 何时使用WebSocket？**
- **适用场景**：
  - **实时通信**：如聊天室、在线协作编辑。
  - **高频数据更新**：如股票行情、实时监控仪表盘。
  - **低延迟交互**：如在线游戏、视频会议。

- **对比HTTP**：
  - **传统HTTP**：客户端主动请求，服务器响应后断开（单向、高延迟）。
  - **WebSocket**：建立持久连接，双方可随时主动推送数据（双向、低延迟）。

---

### **5. 配置注意事项**
- **依赖支持**：确保项目引入了WebSocket库（如Java EE的`javax.websocket`或Spring Boot的`spring-boot-starter-websocket`）。
- **Spring Boot配置**：如果使用Spring Boot，需添加`@Configuration`和`ServerEndpointExporter` Bean：
  ```java
  @Configuration
  public class WebSocketConfig {
      @Bean
      public ServerEndpointExporter serverEndpointExporter() {
          return new ServerEndpointExporter();
      }
  }
  ```

---

### **总结**
- **`@ServerEndpoint`**：定义WebSocket端点及其URI。
- **生命周期注解**：处理连接建立、消息接收、连接关闭事件。
- **使用场景**：需要双向实时通信时优先选择WebSocket，而非传统的轮询或长轮询。





# 理解补充

后端建立好websocket相关的定西，定义好@ServerEndpoint("/webSocket")如下

~~~java
@Component
@ServerEndpoint("/webSocket")
@Slf4j
public class WebSocket {

    private Session session;
    private static final CopyOnWriteArraySet<WebSocket> webSocketSet = new CopyOnWriteArraySet<>();

    @OnOpen
    public void onOpen(Session session) {
        this.session = session;
        webSocketSet.add(this);
        log.info("【websocket消息】有新的连接, 总数:{}", webSocketSet.size());
    }

    @OnClose
    public void onClose() {
        webSocketSet.remove(this);
        log.info("【websocket消息】连接断开, 总数:{}", webSocketSet.size());
    }

    @OnMessage
    public void onMessage(String message) {
        log.info("【websocket消息】收到客户端发来的消息:{}", message);
    }

    public void sendMessage(String message) {
        for (WebSocket webSocket: webSocketSet) {
            log.info("【websocket消息】广播消息, message={}", message);
            try {
                webSocket.session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

前端主动发起ws:localhost:8080/websocket

然后后端调用websocket实例，可以使用自动装配







