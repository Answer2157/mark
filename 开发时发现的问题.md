# Java基础

## 概念

### Java的特点

1. 简单易学(语法简单)
2. 面向对象(封装、继承、多态)
3. 平台无关性(Java虚拟机实现了平台无关性)
4. 支持多线程(C++语言没有内置的多线程机制，而Java语言提供了多线程支持)

****

# equals()方法避免空指针报错

在Java中，`NullPointerException`（空指针异常）是常见的运行时错误，通常发生在尝试调用一个`null`对象的方法或访问其属性时。在你的代码片段中：

```java
role.getRoleName().equals("管理员")
```

如果出现空指针异常，可能的原因如下：

### 1. `role`对象为`null`
如果`role`本身是`null`，那么调用`role.getRoleName()`时就会直接抛出空指针异常。因为`null`对象不能调用任何方法。

**示例：**
```java
Role role = null;
if (role.getRoleName().equals("管理员")) {
    // do something
}
```
运行时会直接抛出：
```
NullPointerException: Cannot invoke "Role.getRoleName()" because "role" is null
```

### 2. `role.getRoleName()`返回`null`
即使`role`对象本身不为`null`，但如果`role.getRoleName()`返回`null`，那么在调用`equals`方法时也会抛出空指针异常。因为`null`不能调用`equals`方法。

**示例：**
```java
Role role = new Role();
role.setRoleName(null); // 假设roleName是null
if (role.getRoleName().equals("管理员")) {
    // do something
}
```
运行时会抛出：
```
NullPointerException: Cannot invoke "String.equals(Object)" because the return value of "role.getRoleName()" is null
```

### 如何避免空指针异常
为了避免空指针异常，可以在调用`equals`方法之前进行`null`检查。以下是几种常见的解决方法：

#### 方法1：显式检查`null`
在调用`equals`之前，先检查`role`和`role.getRoleName()`是否为`null`：
```java
if (role != null && role.getRoleName() != null && role.getRoleName().equals("管理员")) {
    // do something
}
```

#### 方法2：使用`Objects.equals`（推荐）
Java 7引入了`java.util.Objects`类，其中的`equals`方法可以安全地比较两个对象，即使其中一个或两个都是`null`也不会抛出异常：
```java
if (Objects.equals(role.getRoleName(), "管理员")) {
    // do something
}
```
这种方式更简洁，也更安全。

#### 方法3：使用字符串常量调用`equals`
由于字符串常量本身不可能为`null`，可以将字符串常量放在`equals`方法的左边：
```java
if ("管理员".equals(role.getRoleName())) {
    // do something
}
```
这样，即使`role.getRoleName()`返回`null`，也不会抛出空指针异常，因为`"管理员".equals(null)`会安全地返回`false`。

### 总结
空指针异常通常是由于对`null`对象进行操作导致的。在你的代码中，`role`或`role.getRoleName()`为`null`都可能导致问题。通过显式检查`null`或使用更安全的方法（如`Objects.equals`），可以有效避免这种异常。

## 时间戳

~~~Java
//实现方式：
long timestamp = System.currentTimeMillis()
~~~

****

# mapper完成批量操作

~~~xml
<delete id="deleteBatchByStudentIds">
        DELETE FROM course_score
        WHERE student_id IN
        <foreach item="id" collection="batch"
                 open="(" separator="," close=")">
            #{id}
        </foreach>
</delete>解释一下上述代码
~~~

上述代码是一段使用 MyBatis 框架编写的 XML 配置，用于批量删除数据库中 `course_score` 表中与指定学生 ID 相关的记录。以下是对这段代码的详细解释：

1. **`<delete>` 标签**：这个标签用于定义一个 SQL 删除语句。在 MyBatis 中，`<delete>` 标签用于编写删除操作的 SQL 语句。

2. **`id="deleteBatchByStudentIds"`**：这是这个 SQL 语句的唯一标识符，通常用于在 MyBatis 映射文件中引用这个删除操作。通过这个 ID，可以在 Java 代码中调用这个删除操作。

3. **`DELETE FROM course_score`**：这部分是标准的 SQL 语句，用于从 `course_score` 表中删除记录。

4. **`WHERE student_id IN`**：这是 SQL 的条件部分，表示要删除的记录是那些 `student_id` 在指定集合中的记录。

5. **`<foreach>` 标签**：这是 MyBatis 提供的一个动态 SQL 标签，用于迭代集合并生成 SQL 语句。它的作用是在 SQL 中生成一个用逗号分隔的列表。

   - **`item="id"`**：表示在迭代过程中每个元素的变量名是 `id`。
   - **`collection="batch"`**：指定要迭代的集合的名称，这个集合通常是在 Java 代码中传递给 MyBatis 的参数。
   - **`open="("`** 和 **`close=")"`**：在生成的 SQL 语句中，这些属性用于在列表的开头和结尾分别添加一个左括号和一个右括号。
   - **`separator=","`**：指定在生成的列表中，元素之间用逗号分隔。
   - **`#{id}`**：这是 MyBatis 的占位符语法，用于在 SQL 语句中插入参数值。在迭代过程中，`#{id}` 会被替换为集合中当前元素的值。

综上所述，这段代码的作用是根据提供的一组学生 ID，删除 `course_score` 表中对应的记录。通过使用 MyBatis 的 `<foreach>` 标签，可以方便地生成一个适用于 SQL `IN` 子句的参数列表，实现批量删除的功能。

****

# 使用注解校验参数

1. 引入依赖坐标

   ~~~xml
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-validation</artifactId>
           </dependency>
   ~~~

2. **相关注解：**

   1. **`@NotNull`**：确保字段的值不是 `null`。

   2. **`@NotEmpty`**：确保集合、数组或字符串不是 `null` 并且长度大于 0。

   3. **`@NotBlank`**：确保字符串不是 `null` 并且去除空白字符后长度大于 0（用于字符串）。

   4. **`@Size`**：用于验证集合、数组或字符串的大小（长度），可以指定 `min` 和 `max` 属性。

      ```java
      @Size(min = 2, max = 14)
      private String username;
      ```

   5. **`@Min` 和 `@Max`**：用于验证数值型字段的最小值和最大值。

      ```java
      @Min(18)
      @Max(65)
      private int age;
      ```

   6. **`@Email`**：验证字符串是否是一个合法的电子邮件地址。

      ```java
      @Email
      private String email;
      ```

   7. **`@Pattern`**：用于验证字符串是否符合指定的正则表达式。

      ```java
      @Pattern(regexp = "^[a-zA-Z0-9]+$")
      private String alphanumeric;
      ```

   8. **`@Positive` 和 `@PositiveOrZero`**：用于验证数值是否为正数或正数包括零。

   9. **`@Negative` 和 `@NegativeOrZero`**：用于验证数值是否为负数或负数包括零。

   10. **`@Past` 和 `@PastOrPresent`**：用于验证日期是否是过去的日期或截至当前日期。

   11. **`@Future` 和 `@FutureOrPresent`**：用于验证日期是否是将来的日期或从当前日期开始。

3. **生效办法**：在请求参数前面加上@Valid注解

   ~~~java
   @PostMapping("/register")
   public Result<String> register(@Valid @RequestBody UserRegisterDTO userRegisterDTO, HttpServletRequest request) {
   	userRegisterDTO.setRegisterIp(IpUtils.getIpAddr(request));
       Boolean res = iUserService.register(userRegisterDTO);
       return res ? Result.success("注册成功", true) : Result.success("注册失败", true);
   }
   ~~~

   
